## CMS收集器

+ CMS(Concurrent Mark Sweep)收集器，以获取最短的回收停顿时间（STW）为目标，多数应用于互联网网站或者B/S系统的服务端上

+ CMS基于***标记-清除***算法实现的，整个过程分为4个步骤（宏观的阶段）
   - 1 初始标记 CMS initial mark
   - 2 并发标记 CMS concurrent mark
   - 3 重新标记 CMS remark
   - 4 并发清除 CMS concurrent sweep
   - 其中初始标记和重新标记仍然需要STW
   - 初始标记只是标记一下GC Roots能直接关联到的对象，速度很快
   - 并发标记就是进行GC Roots Tracing的过程
   - 重新标记阶段则是为了修正并发标记阶段因用户程序继续工作而导致标记产生变动那一部分对象的标记记录，这个阶段的停顿一般会比初始标记稍微长一些，
   但远比并发标记阶段时间少
   - 在整个运作过程中，在整个耗时最长的并发标记和并发清除阶段收集器线程和用户线程在一起工作，因此从整体上看，CMS收集器的内存回收过程是用户线程
   一起并发执行的。
   
+ 优点
   - 并发收集，停顿低，Oracle一些官方文档中也称之为并发低停顿收集器 Concurrent Low Pause Collector

+ 缺点
   - CMS收集器对cpu资源非常敏感
   - CMS收集器无法处理***浮动垃圾 Floating Garbage***，可能出现 Concurrent Mod Failure 失败而导致另一次Full GC，如果在应用中老年代
   增长不是很快，可以动态调高参数 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获得更高的性能。如果
   CMS运行期间预留的空间无法满足程序需要时，虚拟机将启动后备预案，临时启用 Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就更长
   了，所以 -XX:CMSInitiatingOccupancyFraction 设置的太高很容易导致大量 Concurrent Mod Failure，性能反而降低
   - 收集结束时会有大量的碎片产生，空间碎片过多时，将会给大对象的分配带来麻烦，往往出现老年代还有很多剩余空间，但是无法找到足够大的连续空间来
   分配大对象，不得不提前进行一次Full GC，CMS还提供了一个参数 -XX:UseCMSCompactAtFullCollection 开关参数（默认开启），用于在CMS收集器
   顶不住要进行Full GC时候来开启内存随便的整理合并过程，内存整理的过程是无法并发的，碎片的问题没了，但是停顿时间不得不变长。
   
+ 空间分配担保
   - 在发生Minor GC之前，虚拟机会先检查老年代最大的连续空间是否大于新生代对象所占空间的综合，如果这个条件成立，那么MinorGC可以确保是安全的。
   当大量对象在MinorGC之后仍然存活，就需要老年代进行空间分配担保，把Survivor空间无法容纳的对象直接进入老年代，如果老年代判断剩余空间不足，
   根据以往每一次回收晋升到老年代对象容量的平均值作为经验值，则进行一次Full GC
   
+ 收集器步骤完整过程 [这里一篇文章](https://blog.csdn.net/zqz_zqz/article/details/70568819)
   - 1 Initial Mark
      * 这个是CMS两次STW其中的一个，这个阶段总目标是 标记那些直接被GC ROOTS或者年轻代存活对象所引用的所有对象（老年代）
   - 2 Concurrent Mark
      * 这个阶段垃圾收集线程会遍历老年代，根据上个阶段找到的存活对象，遍历老年代，标记所有存活的对象。并发标记阶段，会和用户线程一起执行。
      并不是老年代所有的存活对象都会被标记，因为用户程序会改变一些对象的引用。
   - 3 Concurrent Preclean
      * 这也是一个并发阶段，与应用的线程并发执行，不会stop应用的线程。在并发运行的过程中，一些对象的引用可能发生变化，这种情况发生时候，
      会将这些对象的区域（Card）标记为Dirty，这也就是 Card Marking
      * 在preclean阶段，那些能够从Dirty对象可达的对象也会被标记，这个标记做完之后，dirty card 标记就会被清除了
      * 这一阶段的目标是：老年代由于用户线程并发执行导致一些第二步中引用改变了的对象，然后把这些对象可达的所有对象标记为存活
   - 4 Concurrent Abortable Preclean
      * 这也是一个并发标记阶段，不会影响用户线程。
      * 这个阶段为了尽量承担STW（Final Mark）中最终标记的工作，这个阶段持续时间依赖于很多因素，由于这个阶段在重复做很多同样的工作，直到满足
      一些条件（比如 重复迭代的次数，完成的工作量或者时钟时间等）才会停止
   - 5 Final Mark
      * 第二个STW阶段，这个阶段的目标是标记老年代中所有的存活对象
      * 通常最终标记阶段会在年轻代尽可能干净的时候执行，扫描的区域是整个年轻代和老年代，老年代对象可能被新生代引用，哪怕新生代对象已经不可达，
      但是老年代对象被新生代对象引用，这些新生代对象会被作为老年代的类似GC ROOTS，当此阶段耗时较长的时候，可以加入参数-XX:+CMSScavengeBeforeRemark，
      在重新标记之前，先执行一次ygc，回收掉年轻代的无用的对象，并将对象放入Survivor或晋升到老年代，这样再进行年轻代扫描时，只需要扫描幸存区的对象即可，
      一般Survivor非常小，这大大减少了扫描时间，由于之前的预处理阶段是与用户线程并发执行的，这时候可能年轻带的对象对老年代的引用已经发生了很多改变，这个
      时候，remark阶段要花很多时间处理这些改变，会导致很长stop the word，所以通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候。
      * 经历过五个阶段的标记之后，老年代所有存活对象都被标记了，现在可以通过清除算法来清理老年代不用的对象。
   - 6 Concurrent Sweep
      * 用户阶段并发执行
      * 清理掉没用的对象
   - 7 Concurrent Reset
      * 重设CMS内部数据结构，为下一次周期作准备


