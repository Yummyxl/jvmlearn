## 概览

+ 堆 Heap
   - 堆里存放的是对象的实例
   - 是java虚拟机管理内存最大的一块
   - GC主要的工作区域，为了高效的垃圾回收，将堆分为更多的子区域
   - 线程共享的区域
   
+ 方法区
   - 存放每个class的结构信息，包括常量池、字段描述、方法描述等
   - GC的非主要工作区域
   - 主要回收废弃常量和没用的类
   - 回收的三个条件
      * 该类所有的实例已经被gc了，也就是jvm中不存在任何该类的实例
      * 加载该类的classLoader已经被gc
      * 该类对应的java.lang.class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类方法
   
+ public void test() {Object obj = new Object();}
   - 生成了两部分内存区域，1）obj这个局部变量在栈（这个指的是栈帧中操作数栈），是方法内的变量  2）真正的Object class的实例对象，放到Heap中
   - 上述的new语句一共消耗了12bytes的空间，JVM规定引用占4个bytes（在JVM Stack中），而空对象在Heap中占8Bytes
   - 方法结束后，对应的stack中空间马上回收，但是Heap中的对象要等到GC来回收
   
+ 垃圾判断算法
   - 引用技术算法，对象有一个引用计数器，被引用计数器增1，任何时刻计数器为0为垃圾，但无法解决循环引用的问题。
   - 根搜索算法
      * 在实际的生产语言中比如java c#等都是采用根搜索算法判定对象是否存活
      * 通过一系列的成为***GC ROOTs***的对象作为起始点向下搜索，当一个对象到gc roots没有任何引用链，则证明此对象不可用

+ jvm常见垃圾回收算法
   - 标记清除 mark-sweep
      * 分为 标记 和 清除 两个步骤，首先需要标记出需要回收的对象，然后回收需要的对象
      * 缺点 1）效率问题，标记和清除效率都不高 2）空间问题，标记清除之后会产生大量的不连续的内存碎片，空间碎片太多会导致后续使用中无法找到
      足够的连续内存而提前触发另一次垃圾收集动作
   - 标记整理 mark-compact
      * 标记过程和标记清除一样，但后续步骤不是进行直接清理而是将所有存活的对象移动到另外一端，然后直接清理掉这端边界以外的内存
      * 没有内存碎片
      * 比标记清除耗费更多的时间进行compact
      
   - 复制算法 copying
      * 将可用内存划分为两块，每次只使用其中的一块，当半区内存使用完了，仅将存活的对象复制到另外一块儿上面，然后把原来的整块内存空间直接清理
      * 这样使得每次内存区域回收都是对整个半区的回收，内存分配时候也就不用考虑内存碎片问题等复杂情况，只需移动堆顶指针，按照顺序分配内存就可以，
      实现简单，运行高效，***只是这样代价就是将内存区域缩小为原来的一半，代价太高***。
      * 现在的商业虚拟机中都是用了这一算法来回收新生代对象
      * 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间，当回收时候将Eden和Survivor空间存活的
      对象一次性复制到另外一块Survivor空间，然后清理掉Eden和使用过的Survivor空间。
      * Oracle Hotspot虚拟机默认将Eden和Survivor空间比例为8比1，也就是每次只有百分之10内存空间浪费。
      * ***复制算法在对象存活率高的时候效率有所下降***
      * 如果不想浪费百分之50空间，就需要用额外的空间进行分配担保用于应付半区内所有对象都100%存活的极端情况，所以在老年代一半不能直接采用
      这种算法。
      * 只需要扫描存活的对象，效率更高
      * 不会产生碎片
      * 需要浪费额外的内存作为复制区
      * 复制算法非常适合生命周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比较小
      * 根据IBM的专门研究，98%的Java对象只会存活1个GC周期，对这些d对象很适合用复制算法，而且不用1比1划分工作区和复制区的比例。
   - 分代算法 generational
      * 当前商业虚拟机都是采用分代收集，根据对象不同的存活周期会将内存分为不同的区域
      * 一般将java堆分为新生代和老年代，这样就可以根据各个代的特点采用不同的垃圾收集算法，譬如年轻代每次都有大批对象死亡，只有少量存活，那
      么只需要使用复制算法，只需要付出少量存活对象的复制成本就可以完成收集过程。
      * 新生代复制算法 老年代标记清除或者标记整理
      * HotSpot 6 共分为三个代，年轻代 老年代 永久代
      
+ 引用类型 分为四种 Strong Soft Weak Phantom
   - Strong 即默认通过 Object object = new Object()这种方式赋值的引用
   - Soft Weak Phantom都是继承自Reference
   - 在Full GC时候会对Reference类型对引用进行特殊处理
      * Soft 内存不够时或被GC，长期不用也会被GC
      * Weak 一定会被GC，当被mark为dead时，会在ReferenceQueue中通知
      * Phantom 本来就没引用，当从jvm heap中释放时会通知
      
+ GC的时机
   - 在分代模型的基础上，GC从时机上来说分为Scavenge GC 和 Full GC
   - Scavenge GC（Minor GC）
      * 触发时机：新生代生成时候，Eden区满了
      * 理论上Scavenge GC会回收大部分Eden区的对象，复制算法的效率很高，Scavenge GC的时间较短
   - Full GC
      * 对整个JVM进行回收，包括新生代 老年代 永久代（方法区）
      * 主要对触发时机 1）老年代满了 2）永久代或者方法区满了 3）System.gc()
      * 效率很低，尽量减少Full GC
      
+ 垃圾收集器
   - 没有万能的收集器
   - 并行与并发
      * 并行（Parallel） 指多个收集器的线程同时工作，但是用户线程处于等待状态
      * 并发（Concurrent）指收集器工作的同时运行用户线程工作
         + 并发不代表解决来GC的停顿的问题，在关键的步骤还是要停顿，比如在收集器标记垃圾的时候。但是在清理垃圾的时候，用户线程可以和垃圾
         收集器线程并发执行
   - Serial收集器
      * 单线程收集器
      * 收集时会暂停所有线程，STW，使用复制算法，虚拟机在Client模式时候的默认新生代收集器
      * 新生代和老年代都可以使用，新生代采用复制算法，老年代采用标记整理算法
      * 单线程GC，没有多余的开销，简单实用
   - ParNew收集器
      * 是Serial的多线程版本，除了实用多个收集线程外，其余行为包括算法 STW 对象分配规则 回收策略等斗鱼Serial一样
      * 这种收集器是默认的运行在Server模式下虚拟机新生代的收集器，在单CPU下 ParNew不一定比Serial效果更好
      * 实用复制算法，因为是针对新生代
      * 可以通过 -XX:ParallelGCThreads来控制GC线程数的多少，需要结合CPU个数
      * 虚拟机在Server下的默认新生代收集器
   - Parallel Scavenge 收集器
      * 多线程版本收集器 
      * 复制算法
      * 对象分配规则和回收策略与ParNew有所不同，它是以吞吐量最大化即GC时间占总时间的比例最小为目标的收集器实现，允许较长时间的STW
      来换取总吞吐量最大。
   - Serial Old
      * Serial的老年代版本
   - Parallel Old
      * Parallel Scavenge的老年代实现
      * 在jvm1.6才出现 Parallel Old
      * 采用标记整理算法，多线程
      * 更注重吞吐量
      * Parallel Scavenge + Parallel Old = 高吞吐量，但GC停顿可能不理想
   - CMS (Concurrent Mark Sweep)
      * 追求最短停顿时间，非常适合web应用
      * 针对老年代，一般和ParNew配合使用
      * Concurrent，GC线程和用户线程并发执行
      * Mark Sweep
      * 只有在多cpu才有意义
      * 使用 -XX:+UseConcMarkSweepGC打开
      * CMS以牺牲CPU资源的代价来减少用户线程的停顿，当CPU个数小于4的时候，可能对系统吞吐量影响较大
      * CMS在并发清理的适合，用户线程还在工作，所以需要预留一部分空间给用户线程
      * CMS采用标记清除算法，会造成较多的碎片，当碎片过多的时候会造成频繁的FUll GC

+ 内存泄漏的经典原因
   - 对象定义在错误的范围内，Wrong Scope
   - 异常处理不当
   - 集合数据管理不当
      
      