+ 枚举根节点
   - 当执行系统停顿下来后，并不需要一个不漏的检查所有执行上下文和全局引用的位置，虚拟机应当是有办法直接得到那哪些地方存放着对象引用，在HotSpot
   实现中，使用一组成为OopMap的数据结构来达到这个目的的。[这里有一篇文章](https://www.cnblogs.com/strinkbug/p/6376525.html)
   - 总而言之，GC停顿的时候，虚拟机可以通过OopMap这样的一个映射表知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录着栈和寄存器中哪些位置是引用

+ 安全点
   - 在OopMap的协助下，HotSpot可以快速并且准确的完成 GC ROOTS 的枚举，但一个很现实的问题随之而来。可能引起OopMap引起变化的指令很多，如果为
   每一条指令都生成自己的OopMap，那么将需要耗费大量的额外空间，这样gc的空间成本将会变得很高。
   - 实际上，HotSpot并没有为每一条指令都生成OopMap，而只是在***特定的位置***记录这些信息，这些位置称为***安全点Safe Point***，即程序执行
   时候并非在所有地方都能停顿下来执行gc，只有在达到安全点时候才能暂停执行。
   - SafePoint的即不能选取的太少以至于让GC等待时间过长，也不能选取太频繁以至于过分增大运行时的负担。安全点选定的基本原则是***是否具有让程序
   长时间执行的特征***为标准选定的，因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而长时间运行，长时间执行的最明显特征
   就是指令序列复用，比如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生SafePoint。
   - 对于安全点来说，另一个需要考虑的问题是如何让所有线程（这里不包括执行JNI调用的线程）在gc发生时都跑到最近的安全点上停顿下来，两种方式，抢占式
   中断和主动式中断。
      * 抢占式中断，GC时主动通知每一个线程，若线程不在安全点上，就唤醒线程执行到最近的安全点上
      * 主动式中断，GC时会设置一个中断标志，不直接操作线程，线程会轮询这个标志，轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方
      * 现在虚拟机几乎没有采用抢占式中断
      
+ 安全区域
   - 在调用SafePoint似乎完美解决了如何进入GC的问题，但实际情况却不一定，SafePoint确保了执行中的线程在不太长的时间内就可以进入到GC的SafaPoint，
   但是无法保证程序不运行，如果程序不是在运行，是在sleep或者Blocked，程序就没有被分配CPU时间，显然JVM也不可能等待线程获取CPU执行时间，这时候线程
   就无法响应gc请求，这个时候就需要安全区域来解决，Safe Reign
   - 当线程执行到SafeReign中的代码时，首先标志自己已经进入来SafeReign，那样JVM在执行gc时就不需要管那些把自己标为处于SafeReign的线程，当线程继续
   执行要离开SafeReign时，它要检查系统是否完成了根节点枚举（或者是整个gc），如果完成了就继续执行，否则就必须等待直到收到可以离开SafeReign的信号为止