## 栈帧 （stack frame）

+ 栈帧是一种帮助虚拟机执行方法调用和方法执行的数据结构

+ 栈帧本身是一种数据结构，封装了 方法的局部变量表、动态链接信息、方法返回地址、操作数栈
   - 方法返回地址 方法被调用的时候总要知道方法执行完跳转的地方，这里记录的就是一块内存地址，记录着方法执行完跳转的地方，不管是正常执行还是
   执行出现异常或者错误
   - 动态链接 符号引用转化为直接引用的过程
      * 符号引用 就是对于目标的完全限定名，存在于常量池中，就是一个标记或者标志，通过这个标志我可以找到我的目标类
      * 直接引用 就是可以直接找到我的目标，可以直接拿到我想要方法的内存地址，这个在编译器是没有的
      * 有些符号引用在类加载或者解析的时候或者第一次使用时就转换成了直接引用，通过完全限定名称转化为指向一块内存地址，这种成为静态解析
      另外一些符号引用每次运行期都会转换为直接引用，这种叫做动态链接，体现为***java的多态***。
   - 操作数栈 
      * 操作真正执行的地方，先进后出的数据结构
      * class文件的Code属性中记录了操作数栈的最大深度，max\_stack
   - 局部变量表
      * 在class文件中Code中已经记录了局部变量的最大个数，max|_locals
      * 最小单位是 slot，每个slot存放32位数据类型，四个字节
      * 对于int char 小于等于两个字节的数据类型用一个slot存储即可，但是对于 long double这种需要64字节才能存储的就需要***两个slot***才能存储
      * slot可以复用，因为每个局部变量的作用域生命周期也是不一样的，但是局部变量表并不区分局部变量的作用域

+ 五种方法调用
   - invokeinterface: 调用接口中的方法，在运行期决定到底调用实现该接口的哪个对象的特定方法。
   - invokestatic: 调用class的静态方法
   - invokespecial: 调用自己的私有方法，调用构造方法(init)，调用父类的方法（实例或构造方法）
   - invokevirtual: 调用虚方法，和多态紧密相关，在运行期动态查找
   - invokedynamic: 动态调用方法。

+ 静态解析的4种情形
   - 静态方法
   - 父类方法
   - 构造方法
   - 私有方法 （共有方法可以被重写），所以私有方法在类加载阶段可以被唯一确定
   - 以上四种方法成为非虚方法，他们在类加载阶段就可以将符号引用解析为直接引用（连接阶段的解析阶段），统一成为静态解析

+ 静态分派与动态分派
   - 静态分派在 section2.bytecode.Test6
   - 动态分派在 section2.bytecode.Test7
   - 区别在于 静态分配是选择执行的哪个方法，在编译器见可知，根据参数的静态类型（包括调用对象的静态类型和传入参数对象的静态类型）来唯一确定
   调用的是哪个类的哪个实例方法。然后根据invokevirtual字节码指令的查找流程来决定到底是（实际上）调用栈顶对象的方法还是它父类的方法，这里是
   实际类型，关于这一点在section2.bytecode.Test8验证
   - 一句话就是静态分派在编译期间确定调用的方法的名字和描述符，动态分派在运行期确定实际的调用对象