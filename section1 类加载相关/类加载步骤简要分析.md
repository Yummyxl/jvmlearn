## 类的加载

+ 类的加载的最终产品是定位于内存中的class对象
+ Class对象封装了类在方法区内的数据结构，并且向java程序员提供了方便的访问方法区内数据结构的接口（反射）
+ 两种类型类加载器
   - java虚拟机自带的类加载器
      * 根类加载器 BootStrap 
         - 内建于Jvm中的启动类加载器会加载java.lang.ClassLoader及其他java平台类，当JVM启动时，一块特殊的
         机器码会执行，会加载扩展类加载器和系统类加载器。这块特殊的机器码叫做启动类加载器（BootStrap）。
         - 启动类加载器并不是java类，其他的加载器却是java类，启动类加载器也是根类加载器是特定于平台的机器指令，负责整个类加载过程。
         - 所有类加载器除了根类加载器，都被实现为java类。不过总要有一个组件来加载第一个java类加载器，从而让整个加载过程可以顺利进行下去，
         加载第一个纯java类加载器就是启动类加载器的职责。
         - 启动类加载器还会负责加载jre运行环境正常运行所需要的基本组件，包括java.util java.lang包等。
      * 扩展类加载器 Extension 只能加载 jar 文件
      * 系统(应用)类加载器 System 
   - 用户自定义的类加载器
      * java.lang.Classloader 子类
      * 用户可以定制类的加载方式
+ 类加载器并不需要等到某个类被"首次主动使用"才加载它
   - jvm规范允许类加载器在预料某个类将要被使用时预先加载它，如果预先加载的过程中遇到类.class文件缺少或存在错误，类加载器必须在类被***首次主动使用***
   时才报告错误（***LinkageError错误***）
   - 如果这个类一直没有被主动程序使用，那么***类加载器就不会报告错误***

## 类的连接

类被加载后，就进入到类连接阶段。
连接就是将已经读入到内存到类到二进制数据合并到虚拟机的运行时环境中去。

### 类的验证

+ 类文件结构检查
+ 语义检查
+ 字节码验证
+ 二进制兼容性验证

### 类的准备

为类变量分配空间并赋予默认值

## 类的初始化

+ 为类变量赋予正确的值，有两种途径
   - 在静态变量的声明处进行初始化
   - 在静态代码块进行赋正确的值
+ 静态变量的声明语句已经静态代码块都被看作是类的初始化语句，java虚拟机都会在类的初始化阶段按照在源代码中他们的声明顺序执行他们
+ 类的初始化步骤
   - 假如这个类还没有被加载和连接，那么先进性这个类的加载和连接
   - 假如这个类存在直接父类，并且这个父类还没有被初始化，那么先初始化直接父类
   - 假如这个类存在初始化语句，那么按照代码顺序依次执行这些初始化语句
+ 初始化对于类和接口的异同点
   - 对于类一定会初始化其父类
   - 对于接口，用到才会初始化，注意这个用到的含义
   
## 类的卸载
+   当Class对象不再被引用，即不可触及时，Class对象就会结束其生命周期，类在方法区内当数据也会被卸载，结束生命周期。***一个类
何时结束生命周期取决于Class对象何时被卸载***
+   java虚拟机自带的类加载器加载的类始终不会被卸载，因为java虚拟机始终会引用这些类加载器，这些类加载器会始终引用加载的类，所以不会被卸载
+   用户自定义的类加载器所加载的类是可以被卸载的
+   在类加载器的内部实现中，用一个java集合定义了所以加载的类的引用（Class对象）。另一方面，一个Class对象总是会引用它的类加载器，
通过调用Class的getClassLoader()方法，就能获得它的类加载器，由此可见，类加载器和类对象是双向引用的关系。一个类的实例总是引用代表这个类的Class
对象，在Object中定义了getClass()方法，这个方法返回代表这个类的class对象，此外所有java类都有一个静态属性class，引用代表这个类的Class对象.

## 类加载器
+ 除了根加载器，其他的类加载器有且只有一个父类
+ 双亲委托机制

   