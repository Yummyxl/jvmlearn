## 类加载器

+ 在双亲委托机制中，各个类加载器按照父子关系形成了***树形结构***，除了根类加载器之外，其余的都有且只有一个父加载器，逻辑意义上的。
+ 双亲委托机制如图所示 ![Image text](https://raw.githubusercontent.com/Yummyxl/jvmlearn/master/pictures/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6.png)
+ 获得ClassLoader的途径
   - 获得当前类的ClassLoader clzz.getClassLoader()
   - 获取当前线程上下文的ClassLoader Thread.currentThread.getContextClassLoader()
   - 获得系统ClassLoader ClassLoader.getSystemClassLoader()
   - 获得调用者的ClassLoader DriverManager.getCallserClassLoader()
+ 命名空间 定义类加载器
   - 每个类加载器都有自己的命名空间，***命名空间由该类加载器及所有的父类加载器共同构成***
   - 在同一个命名空间内，不会出现完全相同的两个类（相同包名 类名）
   - 在不同命名空间内，会出现完全相同的两个类
   - 子加载器加载的类可以访问到父加载器加载的类，父加载器加载的类不能访问到子加载器加载的类
+ 在一个类A中需要加载另一个类B，加载B的类加载器实际上是真正加载类A的类加载器（定义类加载器）
+ 类加载器双亲委托模型好处
   - 可以确保java核心类库的类型安全，所有的Java应用都至少会引用jva.lang.Object类，意思是java.lang.Object在运行期会被加载到jvm中，如果这个
   过程是由程序自定义的类完成的类加载器完成的，那么在jvm中可能存在多个版本的java.lang.Object类，而且这些类不兼容，相互之间不可见（命名空间发挥作用）。
   借助于双亲委托机制，java核心类库的加载动作都是由根类加载器来统一加载，从而确保java应用所使用的都是统一版本核心类库，相互之间兼容。
   - 确保java核心类库所提供的类不会被自定义的类所替代
   - 不同的类加载器可以为相同名称的类创建额外的命名空间，相同名称的类可以并存在jvm中，只需要用不同的类加载器加载即可，不同类加载器加载的类不兼容，相当于
   java虚拟机内部创建了一个有一个相互不兼容的java类空间，这类技术在很多框架中被应用。